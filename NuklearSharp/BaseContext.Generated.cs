// Generated by Sichem at 2/4/2018 1:25:45 AM

using System;

namespace NuklearSharp
{
    unsafe partial class BaseContext
    {
        public uint Convert(NkBuffer<nk_draw_command> cmds, NkBuffer<byte> vertices,
            NkBuffer<ushort> elements,
            NkConvertConfig config)
        {
            return Nk.nk_convert(_ctx, cmds, vertices, elements, config);
        }

        public void InputBegin()
        {
            Nk.nk_input_begin(_ctx);
        }

        public void InputEnd()
        {
            Nk.nk_input_end(_ctx);
        }

        public void InputMotion(int x, int y)
        {
            Nk.nk_input_motion(_ctx, x, y);
        }

        public void InputKey(int key, bool down)
        {
            Nk.nk_input_key(_ctx, key, down ? 1 : 0);
        }

        public void InputButton(int id, int x, int y, bool down)
        {
            Nk.nk_input_button(_ctx, id, x, y, down ? 1 : 0);
        }

        public void InputScroll(NkVec2 val)
        {
            Nk.nk_input_scroll(_ctx, val);
        }

        public void InputGlyph(string glyph)
        {
            fixed (char* glyph_ptr = glyph)
            {
                Nk.nk_input_glyph(_ctx, glyph_ptr);
            }
        }

        public void InputChar(char c)
        {
            Nk.nk_input_char(_ctx, c);
        }

        public void StyleDefault()
        {
            Nk.nk_style_default(_ctx);
        }

        public void StyleFromTable(NkColor[] table)
        {
            Nk.nk_style_from_table(_ctx, table);
        }

        public void StyleSetFont(NkUserFont font)
        {
            Nk.nk_style_set_font(_ctx, font);
        }

        public bool StylePushFont(NkUserFont font)
        {
            return Nk.nk_style_push_font(_ctx, font) != 0;
        }

        public bool StylePopFont()
        {
            return Nk.nk_style_pop_font(_ctx) != 0;
        }

        public bool StylePushStyleItem(NkStyleItem address, NkStyleItem value)
        {
            return Nk.nk_style_push_style_item(_ctx, address, value) != 0;
        }

        public bool StylePushFloat(float* address, float value)
        {
            return Nk.nk_style_push_float(_ctx, address, value) != 0;
        }

        public bool StylePushVec2(NkVec2* address, NkVec2 value)
        {
            return Nk.nk_style_push_vec2(_ctx, address, value) != 0;
        }

        public bool StylePushFlags(uint* address, uint value)
        {
            return Nk.nk_style_push_flags(_ctx, address, value) != 0;
        }

        public bool StylePushColor(NkColor* address, NkColor value)
        {
            return Nk.nk_style_push_color(_ctx, address, value) != 0;
        }

        public bool StylePopStyleItem()
        {
            return Nk.nk_style_pop_style_item(_ctx) != 0;
        }

        public bool StylePopFloat()
        {
            return Nk.nk_style_pop_float(_ctx) != 0;
        }

        public bool StylePopVec2()
        {
            return Nk.nk_style_pop_vec2(_ctx) != 0;
        }

        public bool StylePopFlags()
        {
            return Nk.nk_style_pop_flags(_ctx) != 0;
        }

        public bool StylePopColor()
        {
            return Nk.nk_style_pop_color(_ctx) != 0;
        }

        public bool StyleSetCursor(int c)
        {
            return Nk.nk_style_set_cursor(_ctx, c) != 0;
        }

        public void StyleShowCursor()
        {
            Nk.nk_style_show_cursor(_ctx);
        }

        public void StyleHideCursor()
        {
            Nk.nk_style_hide_cursor(_ctx);
        }

        public void StyleLoadCursor(int cursor, NkCursor c)
        {
            Nk.nk_style_load_cursor(_ctx, cursor, c);
        }

        public void StyleLoadAllCursors(NkCursor[] cursors)
        {
            Nk.nk_style_load_all_cursors(_ctx, cursors);
        }

        public void Setup(NkUserFont font)
        {
            Nk.nk_setup(_ctx, font);
        }

        public void Clear()
        {
            Nk.nk_clear(_ctx);
        }

        public void StartBuffer(NkCommandBuffer buffer)
        {
            Nk.nk_start_buffer(_ctx, buffer);
        }

        public void Start(NkWindow win)
        {
            Nk.nk_start(_ctx, win);
        }

        public bool PanelBegin(string title, int panel_type)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_panel_begin(_ctx, title_ptr, panel_type) != 0;
            }
        }

        public void PanelEnd()
        {
            Nk.nk_panel_end(_ctx);
        }

        public uint* AddValue(NkWindow win, uint name, uint value)
        {
            return Nk.nk_add_value(_ctx, win, name, value);
        }

        public NkWindow FindWindow(uint hash, string name)
        {
            fixed (char* name_ptr = name)
            {
                return Nk.nk_find_window(_ctx, hash, name_ptr);
            }
        }

        public void InsertWindow(NkWindow win, int loc)
        {
            Nk.nk_insert_window(_ctx, win, loc);
        }

        public void RemoveWindow(NkWindow win)
        {
            Nk.nk_remove_window(_ctx, win);
        }

        public bool Begin(string title, NkRect bounds, uint flags)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_begin(_ctx, title_ptr, bounds, flags) != 0;
            }
        }

        public bool BeginTitled(string name, string title, NkRect bounds, uint flags)
        {
            fixed (char* name_ptr = name)
            {
                fixed (char* title_ptr = title)
                {
                    return Nk.nk_begin_titled(_ctx, name_ptr, title_ptr, bounds, flags) != 0;
                }
            }
        }

        public void End()
        {
            Nk.nk_end(_ctx);
        }

        public NkRect WindowGetBounds()
        {
            return Nk.nk_window_get_bounds(_ctx);
        }

        public NkVec2 WindowGetPosition()
        {
            return Nk.nk_window_get_position(_ctx);
        }

        public NkVec2 WindowGetSize()
        {
            return Nk.nk_window_get_size(_ctx);
        }

        public float WindowGetWidth()
        {
            return Nk.nk_window_get_width(_ctx);
        }

        public float WindowGetHeight()
        {
            return Nk.nk_window_get_height(_ctx);
        }

        public NkRect WindowGetContentRegion()
        {
            return Nk.nk_window_get_content_region(_ctx);
        }

        public NkVec2 WindowGetContentRegionMin()
        {
            return Nk.nk_window_get_content_region_min(_ctx);
        }

        public NkVec2 WindowGetContentRegionMax()
        {
            return Nk.nk_window_get_content_region_max(_ctx);
        }

        public NkVec2 WindowGetContentRegionSize()
        {
            return Nk.nk_window_get_content_region_size(_ctx);
        }

        public NkCommandBuffer WindowGetCanvas()
        {
            return Nk.nk_window_get_canvas(_ctx);
        }

        public NkPanel WindowGetPanel()
        {
            return Nk.nk_window_get_panel(_ctx);
        }

        public bool WindowHasFocus()
        {
            return Nk.nk_window_has_focus(_ctx) != 0;
        }

        public bool WindowIsHovered()
        {
            return Nk.nk_window_is_hovered(_ctx) != 0;
        }

        public bool WindowIsAnyHovered()
        {
            return Nk.nk_window_is_any_hovered(_ctx) != 0;
        }

        public bool ItemIsAnyActive()
        {
            return Nk.nk_item_is_any_active(_ctx) != 0;
        }

        public bool WindowIsCollapsed(string name)
        {
            fixed (char* name_ptr = name)
            {
                return Nk.nk_window_is_collapsed(_ctx, name_ptr) != 0;
            }
        }

        public bool WindowIsClosed(string name)
        {
            fixed (char* name_ptr = name)
            {
                return Nk.nk_window_is_closed(_ctx, name_ptr) != 0;
            }
        }

        public bool WindowIsHidden(string name)
        {
            fixed (char* name_ptr = name)
            {
                return Nk.nk_window_is_hidden(_ctx, name_ptr) != 0;
            }
        }

        public bool WindowIsActive(string name)
        {
            fixed (char* name_ptr = name)
            {
                return Nk.nk_window_is_active(_ctx, name_ptr) != 0;
            }
        }

        public NkWindow WindowFind(string name)
        {
            fixed (char* name_ptr = name)
            {
                return Nk.nk_window_find(_ctx, name_ptr);
            }
        }

        public void WindowClose(string name)
        {
            fixed (char* name_ptr = name)
            {
                Nk.nk_window_close(_ctx, name_ptr);
            }
        }

        public void WindowSetBounds(string name, NkRect bounds)
        {
            fixed (char* name_ptr = name)
            {
                Nk.nk_window_set_bounds(_ctx, name_ptr, bounds);
            }
        }

        public void WindowSetPosition(string name, NkVec2 pos)
        {
            fixed (char* name_ptr = name)
            {
                Nk.nk_window_set_position(_ctx, name_ptr, pos);
            }
        }

        public void WindowSetSize(string name, NkVec2 size)
        {
            fixed (char* name_ptr = name)
            {
                Nk.nk_window_set_size(_ctx, name_ptr, size);
            }
        }

        public void WindowCollapse(string name, int c)
        {
            fixed (char* name_ptr = name)
            {
                Nk.nk_window_collapse(_ctx, name_ptr, c);
            }
        }

        public void WindowCollapseIf(string name, int c, int cond)
        {
            fixed (char* name_ptr = name)
            {
                Nk.nk_window_collapse_if(_ctx, name_ptr, c, cond);
            }
        }

        public void WindowShow(string name, int s)
        {
            fixed (char* name_ptr = name)
            {
                Nk.nk_window_show(_ctx, name_ptr, s);
            }
        }

        public void WindowShowIf(string name, int s, int cond)
        {
            fixed (char* name_ptr = name)
            {
                Nk.nk_window_show_if(_ctx, name_ptr, s, cond);
            }
        }

        public void WindowSetFocus(string name)
        {
            fixed (char* name_ptr = name)
            {
                Nk.nk_window_set_focus(_ctx, name_ptr);
            }
        }

        public void MenubarBegin()
        {
            Nk.nk_menubar_begin(_ctx);
        }

        public void MenubarEnd()
        {
            Nk.nk_menubar_end(_ctx);
        }

        public void LayoutSetMinRowHeight(float height)
        {
            Nk.nk_layout_set_min_row_height(_ctx, height);
        }

        public void LayoutResetMinRowHeight()
        {
            Nk.nk_layout_reset_min_row_height(_ctx);
        }

        public void PanelLayout(NkWindow win, float height, int cols)
        {
            Nk.nk_panel_layout(_ctx, win, height, cols);
        }

        public void RowLayout(int fmt, float height, int cols, int width)
        {
            Nk.nk_row_layout_(_ctx, fmt, height, cols, width);
        }

        public float LayoutRatioFromPixel(float pixel_width)
        {
            return Nk.nk_layout_ratio_from_pixel(_ctx, pixel_width);
        }

        public void LayoutRowDynamic(float height, int cols)
        {
            Nk.nk_layout_row_dynamic(_ctx, height, cols);
        }

        public void LayoutRowStatic(float height, int item_width, int cols)
        {
            Nk.nk_layout_row_static(_ctx, height, item_width, cols);
        }

        public void LayoutRowBegin(int fmt, float row_height, int cols)
        {
            Nk.nk_layout_row_begin(_ctx, fmt, row_height, cols);
        }

        public void LayoutRowPush(float ratio_or_width)
        {
            Nk.nk_layout_row_push(_ctx, ratio_or_width);
        }

        public void LayoutRowEnd()
        {
            Nk.nk_layout_row_end(_ctx);
        }

        public void LayoutRow(int fmt, float height, int cols, float[] ratio)
        {
            fixed (float* ptr = ratio)
            {
                Nk.nk_layout_row(_ctx, fmt, height, cols, ptr);
            }
        }

        public void LayoutRowTemplateBegin(float height)
        {
            Nk.nk_layout_row_template_begin(_ctx, height);
        }

        public void LayoutRowTemplatePushDynamic()
        {
            Nk.nk_layout_row_template_push_dynamic(_ctx);
        }

        public void LayoutRowTemplatePushVariable(float min_width)
        {
            Nk.nk_layout_row_template_push_variable(_ctx, min_width);
        }

        public void LayoutRowTemplatePushStatic(float width)
        {
            Nk.nk_layout_row_template_push_static(_ctx, width);
        }

        public void LayoutRowTemplateEnd()
        {
            Nk.nk_layout_row_template_end(_ctx);
        }

        public void LayoutSpaceBegin(int fmt, float height, int widget_count)
        {
            Nk.nk_layout_space_begin(_ctx, fmt, height, widget_count);
        }

        public void LayoutSpaceEnd()
        {
            Nk.nk_layout_space_end(_ctx);
        }

        public void LayoutSpacePush(NkRect rect)
        {
            Nk.nk_layout_space_push(_ctx, rect);
        }

        public NkRect LayoutSpaceBounds()
        {
            return Nk.nk_layout_space_bounds(_ctx);
        }

        public NkRect LayoutWidgetBounds()
        {
            return Nk.nk_layout_widget_bounds(_ctx);
        }

        public NkVec2 LayoutSpaceToScreen(NkVec2 ret)
        {
            return Nk.nk_layout_space_to_screen(_ctx, ret);
        }

        public NkVec2 LayoutSpaceToLocal(NkVec2 ret)
        {
            return Nk.nk_layout_space_to_local(_ctx, ret);
        }

        public NkRect LayoutSpaceRectToScreen(NkRect ret)
        {
            return Nk.nk_layout_space_rect_to_screen(_ctx, ret);
        }

        public NkRect LayoutSpaceRectToLocal(NkRect ret)
        {
            return Nk.nk_layout_space_rect_to_local(_ctx, ret);
        }

        public void PanelAllocRow(NkWindow win)
        {
            Nk.nk_panel_alloc_row(_ctx, win);
        }

        public bool TreeBase(int type, NkImage img, string title, int initial_state, string hash, int line)
        {
            fixed (char* title_ptr = title)
            {
                fixed (char* hash_ptr = hash)
                {
                    return Nk.nk_tree_base(_ctx, type, img, title_ptr, initial_state, hash_ptr, hash.Length, line) != 0;
                }
            }
        }

        public void TreeStatePop()
        {
            Nk.nk_tree_state_pop(_ctx);
        }

        public bool TreePushHashed(int type, string title, int initial_state, string hash, int line)
        {
            fixed (char* title_ptr = title)
            {
                fixed (char* hash_ptr = hash)
                {
                    return Nk.nk_tree_push_hashed(_ctx, type, title_ptr, initial_state, hash_ptr, hash.Length, line) != 0;
                }
            }
        }

        public bool TreeImagePushHashed(int type, NkImage img, string title, int initial_state, string hash, int seed)
        {
            fixed (char* title_ptr = title)
            {
                fixed (char* hash_ptr = hash)
                {
                    return Nk.nk_tree_image_push_hashed(_ctx, type, img, title_ptr, initial_state, hash_ptr, hash.Length, seed) !=
                           0;
                }
            }
        }

        public void TreePop()
        {
            Nk.nk_tree_pop(_ctx);
        }

        public NkRect WidgetBounds()
        {
            return Nk.nk_widget_bounds(_ctx);
        }

        public NkVec2 WidgetPosition()
        {
            return Nk.nk_widget_position(_ctx);
        }

        public NkVec2 WidgetSize()
        {
            return Nk.nk_widget_size(_ctx);
        }

        public float WidgetWidth()
        {
            return Nk.nk_widget_width(_ctx);
        }

        public float WidgetHeight()
        {
            return Nk.nk_widget_height(_ctx);
        }

        public bool WidgetIsHovered()
        {
            return Nk.nk_widget_is_hovered(_ctx) != 0;
        }

        public bool WidgetIsMouseClicked(int btn)
        {
            return Nk.nk_widget_is_mouse_clicked(_ctx, btn) != 0;
        }

        public bool WidgetHasMouseClickDown(int btn, int down)
        {
            return Nk.nk_widget_has_mouse_click_down(_ctx, btn, down) != 0;
        }

        public void Spacing(int cols)
        {
            Nk.nk_spacing(_ctx, cols);
        }

        public void TextColored(string str, uint alignment, NkColor color)
        {
            fixed (char* str_ptr = str)
            {
                Nk.nk_text_colored(_ctx, str_ptr, str.Length, alignment, color);
            }
        }

        public void TextWrapColored(string str, NkColor color)
        {
            fixed (char* str_ptr = str)
            {
                Nk.nk_text_wrap_colored(_ctx, str_ptr, str.Length, color);
            }
        }

        public void Text(string str, uint alignment)
        {
            fixed (char* str_ptr = str)
            {
                Nk.nk_text_(_ctx, str_ptr, str.Length, alignment);
            }
        }

        public void TextWrap(string str)
        {
            fixed (char* str_ptr = str)
            {
                Nk.nk_text_wrap(_ctx, str_ptr, str.Length);
            }
        }

        public void Label(string str, uint alignment)
        {
            fixed (char* str_ptr = str)
            {
                Nk.nk_label(_ctx, str_ptr, alignment);
            }
        }

        public void LabelColored(string str, uint align, NkColor color)
        {
            fixed (char* str_ptr = str)
            {
                Nk.nk_label_colored(_ctx, str_ptr, align, color);
            }
        }

        public void LabelWrap(string str)
        {
            fixed (char* str_ptr = str)
            {
                Nk.nk_label_wrap(_ctx, str_ptr);
            }
        }

        public void LabelColoredWrap(string str, NkColor color)
        {
            fixed (char* str_ptr = str)
            {
                Nk.nk_label_colored_wrap(_ctx, str_ptr, color);
            }
        }

        public void Image(NkImage img)
        {
            Nk.nk_image_(_ctx, img);
        }

        public void ButtonSetBehavior(NkButtonBehavior behavior)
        {
            Nk.nk_button_set_behavior(_ctx, behavior);
        }

        public bool ButtonPushBehavior(NkButtonBehavior behavior)
        {
            return Nk.nk_button_push_behavior(_ctx, behavior) != 0;
        }

        public bool ButtonPopBehavior()
        {
            return Nk.nk_button_pop_behavior(_ctx) != 0;
        }

        public bool ButtonTextStyled(nk_style_button style, string title)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_button_text_styled(_ctx, style, title_ptr, title.Length) != 0;
            }
        }

        public bool ButtonText(string title)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_button_text(_ctx, title_ptr, title.Length) != 0;
            }
        }

        public bool ButtonLabelStyled(nk_style_button style, string title)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_button_label_styled(_ctx, style, title_ptr) != 0;
            }
        }

        public bool ButtonLabel(string title)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_button_label(_ctx, title_ptr) != 0;
            }
        }

        public bool ButtonColor(NkColor color)
        {
            return Nk.nk_button_color(_ctx, color) != 0;
        }

        public bool ButtonSymbolStyled(nk_style_button style, int symbol)
        {
            return Nk.nk_button_symbol_styled(_ctx, style, symbol) != 0;
        }

        public bool ButtonSymbol(int symbol)
        {
            return Nk.nk_button_symbol(_ctx, symbol) != 0;
        }

        public bool ButtonImageStyled(nk_style_button style, NkImage img)
        {
            return Nk.nk_button_image_styled(_ctx, style, img) != 0;
        }

        public bool ButtonImage(NkImage img)
        {
            return Nk.nk_button_image(_ctx, img) != 0;
        }

        public bool ButtonSymbolTextStyled(nk_style_button style, int symbol, string text, uint align)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_button_symbol_text_styled(_ctx, style, symbol, text_ptr, text.Length, align) != 0;
            }
        }

        public bool ButtonSymbolText(int symbol, string text, uint align)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_button_symbol_text(_ctx, symbol, text_ptr, text.Length, align) != 0;
            }
        }

        public bool ButtonSymbolLabel(int symbol, string label, uint align)
        {
            fixed (char* label_ptr = label)
            {
                return Nk.nk_button_symbol_label(_ctx, symbol, label_ptr, align) != 0;
            }
        }

        public bool ButtonSymbolLabelStyled(nk_style_button style, int symbol, string title, uint align)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_button_symbol_label_styled(_ctx, style, symbol, title_ptr, align) != 0;
            }
        }

        public bool ButtonImageTextStyled(nk_style_button style, NkImage img, string text, uint align)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_button_image_text_styled(_ctx, style, img, text_ptr, text.Length, align) != 0;
            }
        }

        public bool ButtonImageText(NkImage img, string text, uint align)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_button_image_text(_ctx, img, text_ptr, text.Length, align) != 0;
            }
        }

        public bool ButtonImageLabel(NkImage img, string label, uint align)
        {
            fixed (char* label_ptr = label)
            {
                return Nk.nk_button_image_label(_ctx, img, label_ptr, align) != 0;
            }
        }

        public bool ButtonImageLabelStyled(nk_style_button style, NkImage img, string label,
            uint text_alignment)
        {
            fixed (char* label_ptr = label)
            {
                return Nk.nk_button_image_label_styled(_ctx, style, img, label_ptr, text_alignment) != 0;
            }
        }

        public bool SelectableText(string str, uint align, ref int value)
        {
            fixed (char* str_ptr = str)
            {
                return Nk.nk_selectable_text(_ctx, str_ptr, str.Length, align, ref value) != 0;
            }
        }

        public bool SelectableImageText(NkImage img, string str, uint align, ref int value)
        {
            fixed (char* str_ptr = str)
            {
                return Nk.nk_selectable_image_text(_ctx, img, str_ptr, str.Length, align, ref value) != 0;
            }
        }

        public bool SelectText(string str, uint align, int value)
        {
            fixed (char* str_ptr = str)
            {
                return Nk.nk_select_text(_ctx, str_ptr, str.Length, align, value) != 0;
            }
        }

        public bool SelectableLabel(string str, uint align, ref int value)
        {
            fixed (char* str_ptr = str)
            {
                return Nk.nk_selectable_label(_ctx, str_ptr, align, ref value) != 0;
            }
        }

        public bool SelectableImageLabel(NkImage img, string str, uint align, ref int value)
        {
            fixed (char* str_ptr = str)
            {
                return Nk.nk_selectable_image_label(_ctx, img, str_ptr, align, ref value) != 0;
            }
        }

        public bool SelectLabel(string str, uint align, int value)
        {
            fixed (char* str_ptr = str)
            {
                return Nk.nk_select_label(_ctx, str_ptr, align, value) != 0;
            }
        }

        public bool SelectImageLabel(NkImage img, string str, uint align, int value)
        {
            fixed (char* str_ptr = str)
            {
                return Nk.nk_select_image_label(_ctx, img, str_ptr, align, value) != 0;
            }
        }

        public bool SelectImageText(NkImage img, string str, uint align, int value)
        {
            fixed (char* str_ptr = str)
            {
                return Nk.nk_select_image_text(_ctx, img, str_ptr, str.Length, align, value) != 0;
            }
        }

        public bool CheckText(string text, bool active)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_check_text(_ctx, text_ptr, text.Length, active ? 1 : 0) != 0;
            }
        }

        public uint CheckFlagsText(string text, uint flags, uint value)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_check_flags_text(_ctx, text_ptr, text.Length, flags, value);
            }
        }

        public bool CheckboxText(string text, ref bool active)
        {
            fixed (char* text_ptr = text)
            {
                int i = active ? 1 : 0;
                var res = Nk.nk_checkbox_text(_ctx, text_ptr, text.Length, &i) != 0;
                active = i != 0;
                return res;
            }
        }

        public bool CheckboxFlagsText(string text, ref uint flags, uint value)
        {
            fixed (char* text_ptr = text)
            {
                uint f = flags;
                var res = Nk.nk_checkbox_flags_text(_ctx, text_ptr, text.Length, &f, value) != 0;

                flags = f;
                return res;
            }
        }

        public bool CheckLabel(string label, bool active)
        {
            fixed (char* label_ptr = label)
            {
                return Nk.nk_check_label(_ctx, label_ptr, active ? 1 : 0) != 0;
            }
        }

        public uint CheckFlagsLabel(string label, uint flags, uint value)
        {
            fixed (char* label_ptr = label)
            {
                return Nk.nk_check_flags_label(_ctx, label_ptr, flags, value);
            }
        }

        public bool CheckboxLabel(string label, ref bool active)
        {
            fixed (char* label_ptr = label)
            {
                int i = active ? 1 : 0;
                var res = Nk.nk_checkbox_label(_ctx, label_ptr, &i) != 0;
                active = i != 0;
                return res;
            }
        }

        public bool CheckboxFlagsLabel(string label, ref uint flags, uint value)
        {
            fixed (char* label_ptr = label)
            {
                uint f = flags;
                var res = Nk.nk_checkbox_flags_label(_ctx, label_ptr, &f, value) != 0;
                flags = f;
                return res;
            }
        }

        public bool OptionText(string text, int is_active)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_option_text(_ctx, text_ptr, text.Length, is_active) != 0;
            }
        }

        public bool RadioText(string text, ref bool active)
        {
            fixed (char* text_ptr = text)
            {
                int i = active ? 1 : 0;
                var res = Nk.nk_radio_text(_ctx, text_ptr, text.Length, &i) != 0;
                active = i != 0;
                return res;
            }
        }

        public bool OptionLabel(string label, bool active)
        {
            fixed (char* label_ptr = label)
            {
                return Nk.nk_option_label(_ctx, label_ptr, active ? 1 : 0) != 0;
            }
        }

        public bool RadioLabel(string label, ref bool active)
        {
            fixed (char* label_ptr = label)
            {
                int i = active ? 1 : 0;
                var res = Nk.nk_radio_label(_ctx, label_ptr, &i) != 0;
                active = i != 0;
                return res;
            }
        }

        public bool SliderFloat(float min_value, ref float value, float max_value, float value_step)
        {
            return Nk.nk_slider_float(_ctx, min_value, ref value, max_value, value_step) != 0;
        }

        public float SlideFloat(float min, float val, float max, float step)
        {
            return Nk.nk_slide_float(_ctx, min, val, max, step);
        }

        public bool SlideInt(int min, int val, int max, int step)
        {
            return Nk.nk_slide_int(_ctx, min, val, max, step) != 0;
        }

        public bool SliderInt(int min, ref int val, int max, int step)
        {
            return Nk.nk_slider_int(_ctx, min, ref val, max, step) != 0;
        }

        public bool Progress(ref ulong cur, ulong max, int is_modifyable)
        {
            ulong temp = cur;
            var res = Nk.nk_progress(_ctx, &temp, max, is_modifyable) != 0;
            cur = temp;

            return res;
        }

        public ulong Prog(ulong cur, ulong max, int modifyable)
        {
            return Nk.nk_prog(_ctx, cur, max, modifyable);
        }

        public void EditFocus(uint flags)
        {
            Nk.nk_edit_focus(_ctx, flags);
        }

        public void EditUnfocus()
        {
            Nk.nk_edit_unfocus(_ctx);
        }

        public uint EditString(uint flags, ref NkStr str, int max, NkPluginFilter filter)
        {
            if (str == null)
            {
                str = new NkStr();
            }

            return Nk.nk_edit_string(_ctx, flags, str, max, filter);
        }

        public uint EditBuffer(uint flags, nk_text_edit edit, NkPluginFilter filter)
        {
            return Nk.nk_edit_buffer(_ctx, flags, edit, filter);
        }

        public void PropertyInt(string name, int min, ref int val, int max, int step, float inc_per_pixel)
        {
            fixed (char* name_ptr = name)
            {
                Nk.nk_property_int(_ctx, name_ptr, min, ref val, max, step, inc_per_pixel);
            }
        }

        public void PropertyFloat(string name, float min, ref float val, float max, float step, float inc_per_pixel)
        {
            fixed (char* name_ptr = name)
            {
                Nk.nk_property_float(_ctx, name_ptr, min, ref val, max, step, inc_per_pixel);
            }
        }

        public void PropertyDouble(string name, double min, ref double val, double max, double step, float inc_per_pixel)
        {
            fixed (char* name_ptr = name)
            {
                Nk.nk_property_double(_ctx, name_ptr, min, ref val, max, step, inc_per_pixel);
            }
        }

        public int Propertyi(string name, int min, int val, int max, int step, float inc_per_pixel)
        {
            fixed (char* name_ptr = name)
            {
                return Nk.nk_propertyi(_ctx, name_ptr, min, val, max, step, inc_per_pixel);
            }
        }

        public float Propertyf(string name, float min, float val, float max, float step, float inc_per_pixel)
        {
            fixed (char* name_ptr = name)
            {
                return Nk.nk_propertyf(_ctx, name_ptr, min, val, max, step, inc_per_pixel);
            }
        }

        public double Propertyd(string name, double min, double val, double max, double step, float inc_per_pixel)
        {
            fixed (char* name_ptr = name)
            {
                return Nk.nk_propertyd(_ctx, name_ptr, min, val, max, step, inc_per_pixel);
            }
        }

        public bool ColorPick(NkColorF color, int fmt)
        {
            return Nk.nk_color_pick(_ctx, &color, fmt) != 0;
        }

        public NkColorF ColorPicker(NkColorF color, int fmt)
        {
            return Nk.nk_color_picker(_ctx, color, fmt);
        }

        public bool ChartBeginColored(int type, NkColor color, NkColor highlight, int count, float min_value,
            float max_value)
        {
            return Nk.nk_chart_begin_colored(_ctx, type, color, highlight, count, min_value, max_value) != 0;
        }

        public bool ChartBegin(int type, int count, float min_value, float max_value)
        {
            return Nk.nk_chart_begin(_ctx, type, count, min_value, max_value) != 0;
        }

        public void ChartAddSlotColored(int type, NkColor color, NkColor highlight, int count,
            float min_value, float max_value)
        {
            Nk.nk_chart_add_slot_colored(_ctx, type, color, highlight, count, min_value, max_value);
        }

        public void ChartAddSlot(int type, int count, float min_value, float max_value)
        {
            Nk.nk_chart_add_slot(_ctx, type, count, min_value, max_value);
        }

        public uint ChartPushLine(NkWindow win, NkChart g, float value, int slot)
        {
            return Nk.nk_chart_push_line(_ctx, win, g, value, slot);
        }

        public uint ChartPushColumn(NkWindow win, NkChart chart, float value, int slot)
        {
            return Nk.nk_chart_push_column(_ctx, win, chart, value, slot);
        }

        public uint ChartPushSlot(float value, int slot)
        {
            return Nk.nk_chart_push_slot(_ctx, value, slot);
        }

        public uint ChartPush(float value)
        {
            return Nk.nk_chart_push(_ctx, value);
        }

        public void ChartEnd()
        {
            Nk.nk_chart_end(_ctx);
        }

        public void Plot(int type, float[] values, int offset)
        {
            fixed (float* ptr = values)
            {
                Nk.nk_plot(_ctx, type, ptr, values.Length, offset);
            }
        }

        public void PlotFunction(int type, IntPtr userdata, NkFloatValueGetter value_getter, int count, int offset)
        {
            Nk.nk_plot_function(_ctx, type, userdata.ToPointer(), value_getter, count, offset);
        }

        public void GroupScrolledEnd()
        {
            Nk.nk_group_scrolled_end(_ctx);
        }

        public bool GroupScrolledBegin(nk_scroll scroll, string title, uint flags)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_group_scrolled_begin(_ctx, scroll, title_ptr, flags) != 0;
            }
        }

        public bool GroupBeginTitled(string id, string title, uint flags)
        {
            fixed (char* id_ptr = id)
            {
                fixed (char* title_ptr = title)
                {
                    return Nk.nk_group_begin_titled(_ctx, id_ptr, title_ptr, flags) != 0;
                }
            }
        }

        public bool GroupBegin(string title, uint flags)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_group_begin(_ctx, title_ptr, flags) != 0;
            }
        }

        public void GroupEnd()
        {
            Nk.nk_group_end(_ctx);
        }

        public bool ListViewBegin(nk_list_view view, string title, uint flags, int row_height, int row_count)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_list_view_begin(_ctx, view, title_ptr, flags, row_height, row_count) != 0;
            }
        }

        public bool PopupBegin(int type, string title, uint flags, NkRect rect)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_popup_begin(_ctx, type, title_ptr, flags, rect) != 0;
            }
        }

        public bool NonblockBegin(uint flags, NkRect body, NkRect header, int panel_type)
        {
            return Nk.nk_nonblock_begin(_ctx, flags, body, header, panel_type) != 0;
        }

        public void PopupClose()
        {
            Nk.nk_popup_close(_ctx);
        }

        public void PopupEnd()
        {
            Nk.nk_popup_end(_ctx);
        }

        public bool TooltipBegin(float width)
        {
            return Nk.nk_tooltip_begin(_ctx, width) != 0;
        }

        public void TooltipEnd()
        {
            Nk.nk_tooltip_end(_ctx);
        }

        public void Tooltip(string text)
        {
            fixed (char* text_ptr = text)
            {
                Nk.nk_tooltip(_ctx, text_ptr);
            }
        }

        public bool ContextualBegin(uint flags, NkVec2 size, NkRect trigger_bounds)
        {
            return Nk.nk_contextual_begin(_ctx, flags, size, trigger_bounds) != 0;
        }

        public bool ContextualItemText(string text, uint alignment)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_contextual_item_text(_ctx, text_ptr, text.Length, alignment) != 0;
            }
        }

        public bool ContextualItemLabel(string label, uint align)
        {
            fixed (char* label_ptr = label)
            {
                return Nk.nk_contextual_item_label(_ctx, label_ptr, align) != 0;
            }
        }

        public bool ContextualItemImageText(NkImage img, string text, uint align)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_contextual_item_image_text(_ctx, img, text_ptr, text.Length, align) != 0;
            }
        }

        public bool ContextualItemImageLabel(NkImage img, string label, uint align)
        {
            fixed (char* label_ptr = label)
            {
                return Nk.nk_contextual_item_image_label(_ctx, img, label_ptr, align) != 0;
            }
        }

        public bool ContextualItemSymbolText(int symbol, string text, uint align)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_contextual_item_symbol_text(_ctx, symbol, text_ptr, text.Length, align) != 0;
            }
        }

        public bool ContextualItemSymbolLabel(int symbol, string text, uint align)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_contextual_item_symbol_label(_ctx, symbol, text_ptr, align) != 0;
            }
        }

        public void ContextualClose()
        {
            Nk.nk_contextual_close(_ctx);
        }

        public void ContextualEnd()
        {
            Nk.nk_contextual_end(_ctx);
        }

        public bool ComboBegin(NkWindow win, NkVec2 size, int is_clicked, NkRect header)
        {
            return Nk.nk_combo_begin(_ctx, win, size, is_clicked, header) != 0;
        }

        public bool ComboBeginText(string selected, NkVec2 size)
        {
            fixed (char* selected_ptr = selected)
            {
                return Nk.nk_combo_begin_text(_ctx, selected_ptr, selected.Length, size) != 0;
            }
        }

        public bool ComboBeginLabel(string selected, NkVec2 size)
        {
            fixed (char* selected_ptr = selected)
            {
                return Nk.nk_combo_begin_label(_ctx, selected_ptr, size) != 0;
            }
        }

        public bool ComboBeginColor(NkColor color, NkVec2 size)
        {
            return Nk.nk_combo_begin_color(_ctx, color, size) != 0;
        }

        public bool ComboBeginSymbol(int symbol, NkVec2 size)
        {
            return Nk.nk_combo_begin_symbol(_ctx, symbol, size) != 0;
        }

        public bool ComboBeginSymbolText(string selected, int symbol, NkVec2 size)
        {
            fixed (char* selected_ptr = selected)
            {
                return Nk.nk_combo_begin_symbol_text(_ctx, selected_ptr, selected.Length, symbol, size) != 0;
            }
        }

        public bool ComboBeginImage(NkImage img, NkVec2 size)
        {
            return Nk.nk_combo_begin_image(_ctx, img, size) != 0;
        }

        public bool ComboBeginImageText(string selected, NkImage img, NkVec2 size)
        {
            fixed (char* selected_ptr = selected)
            {
                return Nk.nk_combo_begin_image_text(_ctx, selected_ptr, selected.Length, img, size) != 0;
            }
        }

        public bool ComboBeginSymbolLabel(string selected, int type, NkVec2 size)
        {
            fixed (char* selected_ptr = selected)
            {
                return Nk.nk_combo_begin_symbol_label(_ctx, selected_ptr, type, size) != 0;
            }
        }

        public bool ComboBeginImageLabel(string selected, NkImage img, NkVec2 size)
        {
            fixed (char* selected_ptr = selected)
            {
                return Nk.nk_combo_begin_image_label(_ctx, selected_ptr, img, size) != 0;
            }
        }

        public bool ComboItemText(string text, uint align)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_combo_item_text(_ctx, text_ptr, text.Length, align) != 0;
            }
        }

        public bool ComboItemLabel(string label, uint align)
        {
            fixed (char* label_ptr = label)
            {
                return Nk.nk_combo_item_label(_ctx, label_ptr, align) != 0;
            }
        }

        public bool ComboItemImageText(NkImage img, string text, uint alignment)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_combo_item_image_text(_ctx, img, text_ptr, text.Length, alignment) != 0;
            }
        }

        public bool ComboItemImageLabel(NkImage img, string text, uint alignment)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_combo_item_image_label(_ctx, img, text_ptr, alignment) != 0;
            }
        }

        public bool ComboItemSymbolText(int sym, string text, uint alignment)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_combo_item_symbol_text(_ctx, sym, text_ptr, text.Length, alignment) != 0;
            }
        }

        public bool ComboItemSymbolLabel(int sym, string label, uint alignment)
        {
            fixed (char* label_ptr = label)
            {
                return Nk.nk_combo_item_symbol_label(_ctx, sym, label_ptr, alignment) != 0;
            }
        }

        public void ComboEnd()
        {
            Nk.nk_combo_end(_ctx);
        }

        public void ComboClose()
        {
            Nk.nk_combo_close(_ctx);
        }

        public bool ComboSeparator(string items_separated_by_separator, int separator, int selected, int count,
            int item_height, NkVec2 size)
        {
            fixed (char* items_separated_by_separator_ptr = items_separated_by_separator)
            {
                return
                    Nk.nk_combo_separator(_ctx, items_separated_by_separator_ptr, separator, selected, count, item_height, size) !=
                    0;
            }
        }

        public bool ComboString(string items_separated_by_zeros, int selected, int count, int item_height,
            NkVec2 size)
        {
            fixed (char* items_separated_by_zeros_ptr = items_separated_by_zeros)
            {
                return Nk.nk_combo_string(_ctx, items_separated_by_zeros_ptr, selected, count, item_height, size) != 0;
            }
        }

        public bool ComboCallback(NkComboCallback item_getter, IntPtr userdata, int selected, int count,
            int item_height, NkVec2 size)
        {
            return Nk.nk_combo_callback(_ctx, item_getter, userdata.ToPointer(), selected, count, item_height, size) != 0;
        }

        public void ComboboxString(string items_separated_by_zeros, ref int selected, int count, int item_height,
            NkVec2 size)
        {
            fixed (char* items_separated_by_zeros_ptr = items_separated_by_zeros)
            {
                int s = selected;
                Nk.nk_combobox_string(_ctx, items_separated_by_zeros_ptr, &s, count, item_height, size);
                selected = s;
            }
        }

        public void ComboboxSeparator(string items_separated_by_separator, int separator, ref int selected, int count,
            int item_height, NkVec2 size)
        {
            fixed (char* items_separated_by_separator_ptr = items_separated_by_separator)
            {
                int s = selected;
                Nk.nk_combobox_separator(_ctx, items_separated_by_separator_ptr, separator, &s, count, item_height, size);
                selected = s;
            }
        }

        public void ComboboxCallback(NkComboCallback item_getter, IntPtr userdata, ref int selected, int count,
            int item_height, NkVec2 size)
        {
            int s = selected;
            Nk.nk_combobox_callback(_ctx, item_getter, userdata.ToPointer(), &s, count, item_height, size);
            selected = s;
        }

        public bool MenuBegin(NkWindow win, string id, int is_clicked, NkRect header, NkVec2 size)
        {
            fixed (char* id_ptr = id)
            {
                return Nk.nk_menu_begin(_ctx, win, id_ptr, is_clicked, header, size) != 0;
            }
        }

        public bool MenuBeginText(string title, uint align, NkVec2 size)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_menu_begin_text(_ctx, title_ptr, title.Length, align, size) != 0;
            }
        }

        public bool MenuBeginLabel(string text, uint align, NkVec2 size)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_menu_begin_label(_ctx, text_ptr, align, size) != 0;
            }
        }

        public bool MenuBeginImage(string id, NkImage img, NkVec2 size)
        {
            fixed (char* id_ptr = id)
            {
                return Nk.nk_menu_begin_image(_ctx, id_ptr, img, size) != 0;
            }
        }

        public bool MenuBeginSymbol(string id, int sym, NkVec2 size)
        {
            fixed (char* id_ptr = id)
            {
                return Nk.nk_menu_begin_symbol(_ctx, id_ptr, sym, size) != 0;
            }
        }

        public bool MenuBeginImageText(string title, uint align, NkImage img, NkVec2 size)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_menu_begin_image_text(_ctx, title_ptr, title.Length, align, img, size) != 0;
            }
        }

        public bool MenuBeginImageLabel(string title, uint align, NkImage img, NkVec2 size)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_menu_begin_image_label(_ctx, title_ptr, align, img, size) != 0;
            }
        }

        public bool MenuBeginSymbolText(string title, uint align, int sym, NkVec2 size)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_menu_begin_symbol_text(_ctx, title_ptr, title.Length, align, sym, size) != 0;
            }
        }

        public bool MenuBeginSymbolLabel(string title, uint align, int sym, NkVec2 size)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_menu_begin_symbol_label(_ctx, title_ptr, align, sym, size) != 0;
            }
        }

        public bool MenuItemText(string title, uint align)
        {
            fixed (char* title_ptr = title)
            {
                return Nk.nk_menu_item_text(_ctx, title_ptr, title.Length, align) != 0;
            }
        }

        public bool MenuItemLabel(string label, uint align)
        {
            fixed (char* label_ptr = label)
            {
                return Nk.nk_menu_item_label(_ctx, label_ptr, align) != 0;
            }
        }

        public bool MenuItemImageLabel(NkImage img, string label, uint align)
        {
            fixed (char* label_ptr = label)
            {
                return Nk.nk_menu_item_image_label(_ctx, img, label_ptr, align) != 0;
            }
        }

        public bool MenuItemImageText(NkImage img, string text, uint align)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_menu_item_image_text(_ctx, img, text_ptr, text.Length, align) != 0;
            }
        }

        public bool MenuItemSymbolText(int sym, string text, uint align)
        {
            fixed (char* text_ptr = text)
            {
                return Nk.nk_menu_item_symbol_text(_ctx, sym, text_ptr, text.Length, align) != 0;
            }
        }

        public bool MenuItemSymbolLabel(int sym, string label, uint align)
        {
            fixed (char* label_ptr = label)
            {
                return Nk.nk_menu_item_symbol_label(_ctx, sym, label_ptr, align) != 0;
            }
        }

        public void MenuClose()
        {
            Nk.nk_menu_close(_ctx);
        }

        public void MenuEnd()
        {
            Nk.nk_menu_end(_ctx);
        }
    }
}